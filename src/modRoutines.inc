'    tiko editor - Programmer's Code Editor for the FreeBASIC Compiler
'    Copyright (C) 2016-2025 Paul Squires, PlanetSquires Software
'
'    This program is free software: you can redistribute it and/or modify
'    it under the terms of the GNU General Public License as published by
'    the Free Software Foundation, either version 3 of the License, or
'    (at your option) any later version.
'
'    This program is distributed in the hope that it will be useful,
'    but WITHOUT any WARRANTY; without even the implied warranty of
'    MERCHANTABILITY or FITNESS for A PARTICULAR PURPOSE.  See the
'    GNU General Public License for more details.

#include once "modRoutines.bi"
#include once "frmOutput.bi"
#include once "frmOptionsCompiler.bi"
#include once "frmOptionsLocal.bi"
#include once "frmProjectOptions.bi"
#include once "frmUserTools.bi"
#include once "frmMain.bi"


' ========================================================================================
' If multiple editor instances is disallowed then bring the current active
' instance to the foreground and pass it whatever command line was intended
' for this instance.
' ========================================================================================
function SpawnPreviousInstance() as boolean
    dim as HWND hWindow = FindWindow(APPCLASSNAME, 0)
    if hWindow then
        SetForegroundWindow(hWindow)
        ' Send the command line to the original editor to be processed
        dim as CWSTR wszPath 
        dim as CWSTR wszArg  
        dim as CWSTR wszSendString  

        dim as long i = 1
        do
            wszArg = AfxCommand(i)
            if len(wszArg) = 0 then exit do
            
            ' Remove any double quotes from the argument.
            wszPath = AfxStrRemove( wszArg, wchr(34) )
            
            ' if no path exists for the file then add the current folder
            wszPath = AfxStrPathname( "PATH", wszArg )
            if len(wszPath) = 0 then wszArg = AfxGetExePathName & wszArg 
            
            wszSendString = wszSendString & _
                            iif(len(wszSendString), ";", "") & _
                            wszArg
            i += 1
        loop
        
        dim as COPYDATASTRUCT cds
        cds.dwData = IDM_COPYDATA_COMMANDLINE
        cds.cbData = (len(wszSendString) + 1) * 2  ' unicode
        cds.lpData = wszSendString.vptr
        SendMessage(hWindow, WM_COPYDATA, 0, cast(LPARAM, @cds))
        return true
    end if

    function = false
end function
    

' ========================================================================================
' Reload a Document based on filename.
' - Used in Replace in Files
' - Used in WM_ACTIVATEAPP to reload externally modified file.
' ========================================================================================
function ReloadDocument( byref wszFilename as wstring ) as long
    dim pDoc as clsDocument ptr
    pDoc = gApp.GetDocumentPtrByFilename( wszFilename )

    if pDoc then
        dim as string sText
        if GetFileToString(wszFilename, sText, pDoc) = false then
            pDoc->SetText( sText ) 
            pDoc->DateFileTime = AfxGetFileLastWriteTime( wszFilename )
        else
            print "Error opening: "; wszFilename
        end if
        
        ' If the document is also already displaying in an open tab then
        ' we need to update the display.
        AfxRedrawWindow( pDoc->hWindow(0))
        AfxRedrawWindow( pDoc->hWindow(1))
    end if
    
    function = 0
end function


' ========================================================================================
' Show context help or general contents if word does not exist
' ========================================================================================
public function ShowContextHelp( byval id as long ) as long

    dim HtmlHelpW as function ( byval hwndCaller as HWND, _
                                byval pswzFile as wstring ptr, _
                                byval uCommand as UNIT, _
                                byval dwData as DWORD_PTR _
                                ) as HWND

    dim as CWSTR wszHelpFilename, wszLabel
    
    ' Ensure that the CurDrive parameter is converted if applicable
    gConfig.CompilerHelpFile = ProcessFromCurdriveApp( gConfig.CompilerHelpFile ) 

    select case id
        case IDM_HELP_FB
            wszLabel = "FreeBASIC "
            ' Convert relative path to absolute path if needed.
            if AfxPathIsRelative(gConfig.CompilerHelpFile) then
                wszHelpFilename = AfxPathCombine(AfxGetExePathName, gConfig.CompilerHelpFile)
            else
                wszHelpFilename = gConfig.CompilerHelpFile
            end if
    end select

    if AfxFileExists(wszHelpFilename) = 0 then
        MessageBoxW( HWND_FRMMAIN, wszLabel & L(244,"Help file not found."), L(201,"Error"), _
                    MB_OK or MB_ICONWARNING or MB_DEFBUTTON1 or MB_APPLMODAL )
        exit function
    end if


    HtmlHelpW = dylibsymbol( gpHelpLib, "HtmlHelpW" )

    if (gpHelpLib = 0) orelse (HtmlHelpW = 0) then
        MessageBox( HWND_FRMMAIN, L(243,"Error loading HtmlHelp."), L(201,"Error"), _
                    MB_OK or MB_ICONWARNING or MB_DEFBUTTON1 or MB_APPLMODAL )
        exit function
    end if

    ' if we are currently in an active document then attempt to lookup the 
    ' word immediately under the caret.
    dim pDoc as clsDocument ptr = gTTabCtl.GetActiveDocumentPtr()
    
    if pDoc = 0 then
        HtmlHelpW( 0, wszHelpFilename, HH_DISPLAY_TOC, null )
        exit function
    end if

    dim wszKeyword as wstring * MAX_PATH
    
    wszKeyword = wstr( pDoc->GetWord )
    
    dim li as HH_AKLINK
    With li
        .cbStruct     = sizeof(HH_AKLINK) 
        .fReserved    = false 
        .pszKeywords  = @wszKeyword
        .pszUrl       = null
        .pszMsgText   = null
        .pszMsgTitle  = null
        .pszWindow    = null
        .fIndexOnFail = false 
    end With
    
    ' Open the help and show the topic
    HtmlHelpW( 0, wszHelpFilename, HH_DISPLAY_TOC, null )   '<-- needed?
    
    if HtmlHelpW( 0, wszHelpFilename, HH_KEYWORD_LOOKUP, cast(DWORD_PTR, @li) ) = 0 then
        ' Normal case search failed, try a ucase search
        wszKeyword     = ucase(wszKeyword)
        li.pszKeywords = @wszKeyword
        HtmlHelpW( 0, wszHelpFilename, HH_KEYWORD_LOOKUP, cast(DWORD_PTR, @li) )
    end if

    function = 0
    
end function


' ========================================================================================
' Get the width of the text in unscaled pixels because we feed this value
' to the pWindow create control function that will then scale up the value.
' ========================================================================================
function getTextWidth( _
            byval hwnd as HWND, _
            byref wszText as wstring, _
            byval FontIndex as long _
            ) as long
    
    dim size as SIZEL
    dim pWindow as CWindow ptr = AfxCWindowPtr(hwnd)
    if pWindow = 0 then exit function
    
    dim as HFONT _hFont
    dim as HFONT oldFont 
    select case FontIndex
        case GUIFONT_9:     _hFont = pWindow->CreateFont(GUIFONT, 9, FW_NORMAL) 
        case GUIFONT_10:    _hFont = pWindow->CreateFont(GUIFONT, 10, FW_NORMAL)
        case SYMBOLFONT_9:  _hFont = pWindow->CreateFont(SYMBOLFONT, 9, FW_NORMAL)
        case SYMBOLFONT_10: _hFont = pWindow->CreateFont(SYMBOLFONT, 10, FW_NORMAL)
        case SYMBOLFONT_12: _hFont = pWindow->CreateFont(SYMBOLFONT, 12, FW_NORMAL)
        case else: exit function    
    end select
    
    dim as HDC hDC = GetDC(hwnd)
    
    SaveDC(hDC)
    if _hFont then oldFont = SelectObject(hDC, _hFont)
    GetTextExtentpoint32( hDC, @wszText, len(wszText), @size )
    SelectObject(hDC, oldFont)
    RestoreDC(hDC, -1)
    
    ReleaseDC(hwnd, hDC)
    if _hFont then DeleteObject(_hFont)
    
    function = pWindow->UnScaleX(size.cx)

end function

' ========================================================================================
' Determine if the mouse cursor is currently over the incoming window
' ========================================================================================
function isMouseOverWindow( byval hChild as HWND ) as boolean
    dim as point pt
    GetCursorPos( @pt )
    if WindowFromPoint( pt ) = hChild then return true
end function

' ========================================================================================
' Determine if the mouse cursor is currently over client RECT area
' ========================================================================================
function isMouseOverRECT( byval hWin as HWND, byval rc as RECT ) as boolean
    dim as point pt
    GetCursorPos( @pt )
    MapWindowpoints( hWin, HWND_DESKTOP, cast( point ptr, @rc), 2 )
    if PtInRect( @rc, pt ) then return true
end function

' ========================================================================================
' Disable all modeless windows belonging to frmMain so that the popup modal is truly modal.
' ========================================================================================
function DisableAllModeless() as long
    ' No need to enable/disable the modeless Help form.
    if IsWindowVisible(HWND_FRMFINDREPLACE) then EnableWindow(HWND_FRMFINDREPLACE, false)
    EnableWindow(HWND_FRMMAIN, false)
    function = 0
end function


' ========================================================================================
' Enable all modeless windows belonging to frmMain.
' ========================================================================================
function EnableAllModeless() as long
    ' No need to enable/disable the modeless Help form.
    if IsWindowVisible(HWND_FRMFINDREPLACE) then EnableWindow(HWND_FRMFINDREPLACE, true)
    EnableWindow(HWND_FRMMAIN, true)
    function = 0
end function


' ========================================================================================
' return temporary file name
' ========================================================================================
function GetTemporaryFilename( _
            byref wszFolder as wstring, _
            byref wszExtension as wstring _
            ) as string

    dim wszTempFilename as wstring * MAX_PATH
    if GetTempFileName( @wszFolder, "TMP", 0, @wszTempFilename ) then
        ' Delete the temp file that gets created b/c we will create it ourselves based on the 
        ' returned filename.
        AfxDeleteFile( wszTempFilename )
        if len(wszExtension) then 
            wszTempFilename = left(wszTempFilename, len(wszTempFilename) -  3) & wszExtension
        end if
    end if      
    function = wszTempFilename
end function


' ========================================================================================
' Get the Scintilla value for a character sets
' ========================================================================================
function GetFontCharSetID(byref wzCharsetName as CWSTR ) as long

    if len(wzCharsetName) = 0 then return SC_CHARSET_DEFAULT
    
    select case wzCharsetName
        case "Default"       : function = SC_CHARSET_DEFAULT
        case "Ansi"          : function = SC_CHARSET_ANSI
        case "Arabic"        : function = SC_CHARSET_ARABIC
        case "Baltic"        : function = SC_CHARSET_BALTIC
        case "Chinese Big 5" : function = SC_CHARSET_CHINESEBIG5
        case "East Europe"   : function = SC_CHARSET_EASTEUROPE
        case "GB 2312"       : function = SC_CHARSET_GB2312
        case "Greek"         : function = SC_CHARSET_GREEK
        case "Hangul"        : function = SC_CHARSET_HANGUL
        case "Hebrew"        : function = SC_CHARSET_HEBREW
        case "Johab"         : function = SC_CHARSET_JOHAB
        case "Mac"           : function = SC_CHARSET_MAC
        case "OEM"           : function = SC_CHARSET_OEM
        case "Russian"       : function = SC_CHARSET_RUSSIAN
        case "Shiftjis"      : function = SC_CHARSET_SHIFTJIS
        case "Symbol"        : function = SC_CHARSET_SYMBOL
        case "Thai"          : function = SC_CHARSET_THAI
        case "Turkish"       : function = SC_CHARSET_TURKISH
        case "Vietnamese"    : function = SC_CHARSET_VIETNAMESE
    end select

end function


' ========================================================================================
' Convert the current text buffer to the specified encoding and redisplay the text.
' ========================================================================================
function ConvertTextBuffer( _
            byval pDoc as clsDocument ptr, _
            byval FileEncoding as long _
            ) as Long
                            
   if pDoc = 0 then exit function

   dim as hwnd hEdit = pDoc->hWndActiveScintilla
   ' Save the current file position and first visible line
   dim nFirstLine as long = SciExec( hEdit, SCI_GETFIRSTVISIBLELINE, 0, 0) 
   Dim nPos As Long = SciExec(hEdit, SCI_GETCURRENTPOS, 0, 0)

   pDoc->FileEncoding = FileEncoding
   Dim As ZString Ptr psz = Cast( ZString Ptr, SciExec(hEdit, SCI_GETCHARACTERPOINTER, 0, 0) )
   dim as long sciCodePage = SciExec(hEdit, SCI_GETCODEPAGE, 0, 0)   ' 0 or SC_CP_UTF8 
   dim as string txtBuffer 
   
   ' Convert buffer to specified file encoding
   select CASE FileEncoding
      case FILE_ENCODING_ANSI
         if sciCodePage = 0 THEN  ' already in ANSI format  
            exit function
         else   
            ' need to convert from UTF8 to ANSI
            txtBuffer = Utf8ToAnsi(*psz)
            SciExec(hEdit, SCI_SETCODEPAGE, 0, 0 )
         end if    

      case FILE_ENCODING_UTF8_BOM, FILE_ENCODING_UTF16_BOM
         if sciCodePage = SC_CP_UTF8 THEN  ' already in unicode format
            exit function
         else
            ' need to convert from ANSI to UTF8
            txtBuffer = AnsiToUtf8(*psz)
            SciExec(hEdit, SCI_SETCODEPAGE, SC_CP_UTF8, 0 )
         end if    

   END SELECT
   
   ' Set the new buffer
   pDoc->SetText(txtBuffer)
   pDoc->UserModified = false

   SciExec(hEdit, SCI_SETFIRSTVISIBLELINE, nFirstLine, 0) 
   SciExec(hEdit, SCI_GOTOPOS, nPos, 0)
   
   function = 0
end function   


' ========================================================================================
' Maps UTF-8 string to Ansi string.
' ========================================================================================
function Utf8ToAnsi(byref strUtf8 as string) as string

   dim i as long                ' // Loop counter
   dim strAscii as string       ' // Ascii string
   dim idx as long              ' // Position in the string
   dim c as long                ' // ASCII code
   dim b2 as long               ' // Second byte
   dim fSkipChar as boolean     ' // Flag

   if len(strUtf8) = 0 then exit function
   
   ' // The maximum length of the translated string will be
   ' // the same as the length of the original string.
   ' // We are pre-allocating the buffer for faster operation
   ' // than concatenating each character one by one.
   strAscii = space(len(strUtf8))

   ' // Intialize index position in the string buffer
   ' // used to store the converted Ascii string
   idx = 1
   
   ' // Examine the contents of each character in the UTF-8 encoded string
   for i = 1 to len(strUtf8)
      ' // If fSkipChar is set we have to skip this character
      if fSkipChar then
         fSkipChar = 0
         continue for
      end if
      ' // Get the Ascii code of the character
      c = asc(mid(strUtf8, i, 1))
      ' // If it is betwen 0 and 127...
      if c < 128 then 
         ' // ...we simply copy it to the string buffer...
         mid(strAscii, idx, 1) = mid(strUtf8, idx, 1)
         ' // ...and increase the position by 1.
         idx = idx + 1
      elseif c < 224 then
         ' // We need to join this byte and the next byte.
         b2 = asc(mid(strUtf8, i + 1, 1))
         if b2 > 127 then
            c = (c - 192) * 64 + (b2 - 128)
            mid(strAscii, idx, 1) = chr(c)
            ' // Set the flag to skip the next character
            fSkipChar = true
            ' // Increase the position by 1.
            idx = idx + 1
         end if
      end if
   next

   ' // Return the string
   function = left(strAscii, idx - 1)

end function


' ========================================================================================
' Maps Unicode character string to a UTF-8 string.
' ========================================================================================
function UnicodeToUtf8( byval wzUnicode as CWSTR ) as string
    dim sUtf8 as string

    ' Maps Unicode character string to a UTF-8 string.
    sUtf8 = string(len(wzUnicode) * 2, 0)
    
    dim as long bytesWritten = _
        WideCharToMultiByte ( _
        CP_UTF8, _                        'Set to UTF-8
        0, _                              'Conversion type
        cast(LPCWSTR, wzUnicode.vptr), _  'Unicode string to convert
        len(wzUnicode), _                 'Length of Unicode string
        cast(LPSTR, strptr(sUtf8)), _     'UTF-8 string
        len(sUtf8), _                     'Length of UTF-8 buffer
        byval 0, _                        'Invalid character replacement
        byval 0)                          'Replacement was used flag

    function = left(sUtf8, bytesWritten)

end function


' ========================================================================================
' Maps Ansi character string to a UTF-8 string.
' ========================================================================================
function AnsiToUtf8( byref sAnsi as string ) as string
    dim sUnicode as string
    dim sUtf8    as string

    'Maps Ansi character string to a UTF-8 string.

    'Step one, convert to UNICODE
    sUnicode = string(len(sAnsi) * 2, 0)
    MultiByteToWideChar(CP_ACP, _                  'System default Windows ANSI code page
                     MB_PRECOMPOSED, _          'Conversion type
                     cast(LPCSTR, strptr(sAnsi)), _     'ANSI string to convert
                     len(sAnsi), _              'Lenght of ANSI string
                     cast(LPWSTR, strptr(sUnicode)), _  'Unicode string
                     len(sUnicode))             'Lenght of Unicode buffer

    'Step two, convert to UTF-8
    sUtf8 = string(len(sAnsi), 0)
    WideCharToMultiByte(CP_UTF8, _                 'Set to UTF-8
                     0, _                       'Conversion type
                     cast(LPCWSTR, strptr(sUnicode)), _  'Unicode string to convert
                     len(sUnicode) / 2, _       'Lenght of Unicode string
                     cast(LPSTR, strptr(sUtf8)), _     'UTF-8 string
                     len(sUtf8), _              'Length of UTF-8 buffer
                     byval 0, _                 'Invalid character replacement
                     byval 0)                   'Replacement was used flag
    function = sUtf8

end function


' ========================================================================================
' Determine if a string is UTF-8 encoded
' ========================================================================================
function isUTF8encoded(byref s as string) as boolean
    dim as integer i = 0, n = len(s)
    dim as ubyte ch

    while i < n
        ch = s[i]
        
        if ch <= &h7F then
            ' ascii character (1 byte)
            i += 1
        elseif ch >= &hC2 andalso ch <= &hDF then
            ' 2-byte sequence
            if i + 1 >= n then return false
            if (s[i + 1] and &hC0) <> &h80 then return false
            i += 2
        elseif ch >= &hE0 andalso ch <= &hEF then
            ' 3-byte sequence
            if i + 2 >= n then return false
            if (s[i + 1] and &hC0) <> &h80 orelse (s[i + 2] and &hC0) <> &h80 then return false
            i += 3
        elseif ch >= &hF0 andalso ch <= &hF4 then
            ' 4-byte sequence
            if i + 3 >= n then return false
            if (s[i + 1] and &hC0) <> &h80 orelse (s[i + 2] and &hC0) <> &h80 orelse (s[i + 3] and &hC0) <> &h80 then return false
            i += 4
        else
            return false
        end if
    wend

    return true
end function


' ========================================================================================
' Open a disk file and read it into a string (ANSI or UTF8)
' ========================================================================================
function GetFileToString( _
            byref wszFilename as const wstring, _
            byref txtBuffer as string, _
            byval pDoc as clsDocument ptr _
            ) as boolean
    
    if pDoc = 0 then return true
    if AfxFileExists(wszFilename) = false then return true
    
    ' Load the entire file into a string
    dim dwCount as DWORD, dwFileSize as DWORD, dwHighSize as DWORD, dwBytesRead as DWORD
    dim hFile as HANDLE = CreateFileW(@wszFileName, GENERIC_READ, FILE_SHARE_READ, null, _
                            OPEN_EXISTING, FILE_FLAG_SEQUENTIAL_SCAN, null)
    if hFile = INVALID_HANDLE_VALUE then return true
    dwFileSize = GetFileSize(hFile, @dwHighSize)
    txtBuffer = string(dwFileSize, 0)
    dim bSuccess as long = ReadFile(hFile, strptr(txtBuffer), dwFileSize, @dwBytesRead, null)
    CloseHandle(hFile)
    if bSuccess = false then return true

    pDoc->FileEncoding = FILE_ENCODING_ANSI

    ' Check for BOM signatures
    if left(txtBuffer, 3) = chr(&HEF, &HBB, &HBF) then
        ' UTF8 BOM encoded 
        pDoc->FileEncoding = FILE_ENCODING_UTF8_BOM
        txtBuffer = mid(txtBuffer, 4)   ' bypass the BOM
    elseif left(txtBuffer, 2) = chr(&HFF, &HFE) then
        ' UTF16 BOM (little endian) encoded
        pDoc->FileEncoding = FILE_ENCODING_UTF16_BOM 
        txtBuffer = mid(txtBuffer, 3)   ' bypass the BOM
    else
        if isUTF8encoded(txtBuffer) then
            pDoc->FileEncoding = FILE_ENCODING_UTF8
        end if
    end if

   select case pDoc->FileEncoding
      case FILE_ENCODING_ANSI 
         ' No conversion needed. clsDocument ApplyProperties will *not*
         ' set the editor to UTF8 code.
      
      case FILE_ENCODING_UTF8, FILE_ENCODING_UTF8_BOM   
         ' No conversion needed. clsDocument ApplyProperties will set
         ' the editor to UTF8 code.
         
      case FILE_ENCODING_UTF16_BOM
         ' Convert the whole buffer to UTF-16 unicode string
         dim as CWSTR wszText = string(len(txtBuffer),0)
         MemCpy( CAST(any PTR, wszText.m_pBuffer), strptr(txtBuffer), len(txtBuffer))

         ' Convert to UTF8 so it can display in the editor
         txtBuffer = UnicodeToUtf8(wszText)

   end select
        
    function = false
end function


' ========================================================================================
' Determine if current line is a valid #Include filename
' ========================================================================================
function IsCurrentLineIncludeFilename() as boolean
    ' Determine if the text under the current line is a valid #Include filename
    ' and return true if it is. if F6 was pressed then the calling program can
    ' simply open/load the gApp.IncludeFilename. if the right click popup menu
    ' is to be shown then simply add the option to open this file.

    dim pDoc as clsDocument ptr = gTTabCtl.GetActiveDocumentPtr()
    if pDoc = 0 then exit function
    
    dim wszPath         as wstring * MAX_PATH
    dim wszIconCompilerPath as wstring * MAX_PATH
    dim wszText         as wstring * MAX_PATH
    dim sFilename       as string 
    dim sLine           as string 
    dim nLine           as long   
    dim i               as long

    dim as long idxBuild = frmBuildConfig_getActiveBuildIndex()
    if idxBuild = -1 then idxBuild = 0
    if gConfig.Builds(idxBuild).Is32bit then wszIconCompilerPath = gConfig.FBWINcompiler32
    if gConfig.Builds(idxBuild).Is64bit then wszIconCompilerPath = gConfig.FBWINcompiler64
    wszIconCompilerPath = ProcessFromCurdriveApp(wszIconCompilerPath)
    wszIconCompilerPath = AfxStrPathname( "PATH", wszIconCompilerPath ) & "inc"

    ' Convert relative path to absolute path if needed.
    if AfxPathIsRelative(wszIconCompilerPath) then
        wszIconCompilerPath = AfxPathCombine(AfxGetExePathName, wszIconCompilerPath)
    end if

    nLine = pDoc->GetCurrentLineNumber()
    sLine = ltrim(pDoc->GetLine(nLine))
    
    if left(ucase(sLine), 9) = "#INCLUDE " then sFilename = mid(sLine, 10)
    if left(ucase(sLine), 14) = "#INCLUDE ONCE " then sFilename = mid(sLine, 15)

    gApp.IncludeFilename = ""   
    if len(sFilename) then
        ' remove any comments at the end of the line
        i = instr(sFilename, "'")
        if i then sFilename = left(sFilename, i-1)
        sFilename = trim(sFilename, any chr(32,34))  ' remove spaces and double quotes
        wszPath = AfxStrPathname( "PATH", pDoc->DiskFilename )

        if AfxFileExists(wszPath & sFilename) then 
            gApp.IncludeFilename = wszPath & sFilename
        elseif AfxFileExists(sFilename) then 
            gApp.IncludeFilename = sFilename
        elseif AfxFileExists(AfxGetCurDir & "\" & sFilename) then 
            gApp.IncludeFilename = AfxGetCurDir & "\" & sFilename
        elseif AfxFileExists(AfxGetExePathName & sFilename) then 
            gApp.IncludeFilename = AfxGetExePathName & sFilename
        elseif AfxFileExists(str(wszIconCompilerPath) & "\" & sFilename) then 
            gApp.IncludeFilename = str(wszIconCompilerPath) & "\" & sFilename
        else
            ' Iterate the optional semi colon separated list of compiler include paths
            dim as CWSTR includePath
            dim as long numpaths = AfxStrParseCount(gConfig.CompilerIncludes, ";")
            for i as long = 1 to numpaths
                includePath = rtrim(AfxStrParse(gConfig.CompilerIncludes, i, ";")) & "\" & sFilename
                if AfxFileExists(includePath) then
                    gApp.IncludeFilename = includePath
                    exit for
                end if
            next
        end if
        gApp.IncludeFilename = AfxStrReplace(gApp.IncludeFilename, "/", "\")
        gApp.IncludeFilename = AfxStrReplace(gApp.IncludeFilename, "\\", "\")
    end if
    
    function = AfxFileExists( gApp.IncludeFilename ) 

end function


' ========================================================================================
' Generic open document handler for when function ListBox item selected or Explorer Treeview
' ========================================================================================
function OpenSelectedDocument( _
            byref wszFilename as wstring, _
            byref wszfunctionName as wstring = "", _
            byval nLineNumber as long = -1 _
            ) as clsDocument ptr

    ' This function is called in the following situations:
    '   1. When a selection is made in the function List.
    '   2. When a selection is made through the Explorer treeview.
    '   3. When a Find In Files line is selected.
    '   4. When a Goto Definition word is clicked on.
    '   5. When OnActivateApp needs to reload a document.
    '   6. When a compile error occurs and need to position to the error line.
    '   7. When right-click select #Include file to open. 
    
    ' if incoming functionName then search for filename and line number.
    dim pData as DB2_DATA ptr    
    if len( wszfunctionName ) andalso nLineNumber = -1 then
        ' Search for function, sub, or property (get/set)
        pData = gdb2.dbFindfunction( wszfunctionName, wszFilename) 
        if pData then
            wszFilename = pData->fileName
            nLineNumber = pData->nLineStart
        end if
    end if
    
    ' Not all documents exist on disk file. for example, a QuickRun file will exist in
    ' the editor but may never have a disk footprint. We need to search the project to
    ' determine if the filename has a pDoc already associated with it. if it does, then
    ' pass that pDoc rather than looking for a disk filename.
    dim pDoc as clsDocument ptr
    pDoc = gApp.GetDocumentPtrByFilename( wszFilename )

    if pDoc then
        pDoc = frmMain_OpenFileSafely( _
                    HWND_FRMMAIN, _
                    false, _    ' bIsNewFile
                    false, _    ' bIsTemplate
                    true, _     ' bShowInTab
                    false, _    ' bIsInclude
                    "", _       ' wszFileName
                    pDoc )      ' pDocIn
    else   
        if AfxFileExists(wszFilename) = false then exit function
        ' Display the document containing the selected sub/function       
        pDoc = frmMain_OpenFileSafely(HWND_FRMMAIN, _
                                false, _    ' bIsNewFile
                                false, _    ' bIsTemplate
                                true, _     ' bShowInTab
                                false, _    ' bIsInclude
                                wszFilename, _  ' wszFileName
                                0 )         ' pDocIn
    end if

    ' Set the top line to display in the editor. I chose to start 3 lines before the
    ' function just to make it visually more appealing.
    if pDoc then
        ' do not reposition if incoming LineNumber is -1 because that value represents
        ' the caller specifically not wanting a repositioning.
        if nLineNumber <> -1 then 
            dim as hwnd hEdit = pDoc->hwndActiveScintilla
            ' ensure that the line is visible (not folded)
            if SciExec( hEdit, SCI_GETLINEVISIBLE, nLineNumber, 0) = false then
                ' unfold the block that contains this hidden line
                pDoc->FoldToggle( nLineNumber )
            end if
            SciExec( hEdit, SCI_SETFIRSTVISIBLELINE, Max(nLineNumber - 3, 0), 0) 
            SciExec( hEdit, SCI_GOTOLINE, nLineNumber, 0) 
            pDoc->CenterCurrentLine
        end if
    end if 
    
    function = pDoc
end function


' ========================================================================================
' Process prefix {CURDRIVE} and convert to current drive letter.
' ========================================================================================
function ProcessToCurdriveApp( byval wszFilename as CWSTR ) as CWSTR
    ' for each folder location determine if it resides on the same drive as
    ' the editor. if it does then substitute the replaceable parameter
    ' {CURDRIVE} for the drive letter. This allows you to easily run the editor
    ' on different media (eg. thumb drive) that may be assigned a different
    ' drive letter.
    dim as CWSTR wszText = AfxGetExePathName

    dim wszCurDrive as CWSTR = lcase(left(wszText, 3))  ' eg. D:\

    ' if the incoming filename is a relative file name then the following test
    ' will have no effect.
    if lcase(left(wszFilename, 3)) = wszCurDrive then 
        wszFilename = wstr("{CURDRIVE}") & mid(wszFilename, 2)
    end if

    return wszFilename
end function


' ========================================================================================
' Process current drive to prefix {CURDRIVE} 
' ========================================================================================
function ProcessFromCurdriveApp( byval wszFilename as CWSTR ) as CWSTR
    ' for each folder location determine if it resides on the same drive as
    ' the editor. if it does then substitute the replaceable parameter
    ' {CURDRIVE} for the drive letter. This allows you to easily run the editor
    ' on different media (eg. thumb drive) that may be assigned a different
    ' drive letter.
    dim as CWSTR wszText = AfxGetExePathName

    if ucase(left(wszFilename, 10)) = wstr("{CURDRIVE}") then 
        wszFilename = left(wszText, 1) & mid(wszFilename, 11)
    end if

    return wszFilename
end function


' ========================================================================================
' Process prefix {CURDRIVE} and convert to current drive letter.
' ========================================================================================
function ProcessToCurdriveProject( byval wszFilename as CWSTR ) as CWSTR
    ' for each folder location determine if it resides on the same drive as
    ' the project file. if it does then substitute the replaceable parameter
    ' {CURDRIVE} for the drive letter. This allows you to easily run the editor
    ' on different media (eg. thumb drive) that may be assigned a different
    ' drive letter.
    dim wszText as CWSTR = gApp.ProjectFilename

    dim wszCurDrive as CWSTR = lcase(left(wszText, 3))  ' eg. D:\

    ' if the incoming filename is a relative file name then the following test
    ' will have no effect.
    if lcase(left(wszFilename, 3)) = wszCurDrive then 
        wszFilename = wstr("{CURDRIVE}") & mid(wszFilename, 2)
    end if

    return wszFilename
end function


' ========================================================================================
' Process current drive to prefix {CURDRIVE} 
' ========================================================================================
function ProcessFromCurdriveProject( byval wszFilename as CWSTR ) as CWSTR
    ' for each folder location determine if it resides on the same drive as
    ' the project file. if it does then substitute the replaceable parameter
    ' {CURDRIVE} for the drive letter. This allows you to easily run the editor
    ' on different media (eg. thumb drive) that may be assigned a different
    ' drive letter.
    dim wszText as CWSTR = gApp.ProjectFilename
    
    if ucase(left(wszFilename, 10)) = wstr("{CURDRIVE}") then 
        wszFilename = left(wszText, 1) & mid(wszFilename, 11)
    end if

    return wszFilename
end function


' ========================================================================================
' Displays the FileOpenDialog.
' The returned pointer must be freed with CoTaskMemFree
' ========================================================================================
function AfxIFileOpenDialogW( _
            byval hwndOwner as HWND, _
            byval idButton as long _
            ) as wstring ptr

    dim hr as long
    dim CLSID_FileOpenDialog as CLSID = (&hDC1C5A9C, &hE88A, &h4DDE, {&hA5, &hA1, &h60, &hF8, &h2A, &h20, &hAE, &hF7})
    dim IID_IFileOpenDialog as GUID   = (&hD57C7288, &hD4AD, &h4768, {&hBE, &h02, &h9D, &h96, &h95, &h32, &hD9, &h60})

    ' Create an instance of the FileOpenDialog object
    dim pofd as IFileOpenDialog ptr
    hr = CoCreateInstance(@CLSID_FileOpenDialog, null, CLSCTX_INPROC_SERVER, @IID_IFileOpenDialog, @pofd)
    if pofd = null then return null

    ' Set the file types depending on the button pushed that calls this open dialog
    dim rgFileTypes(1 To 5) as COMDLG_FILTERSPEC

    select case idButton
        case IDM_LOADSESSION  
            rgFileTypes(1).pszName = @wstr("Session files")
            rgFileTypes(1).pszSpec = @wstr("*.session")
            rgFileTypes(2).pszName = @L(79,"All files")
            rgFileTypes(2).pszSpec = @wstr("*.*")
            pofd->lpVtbl->SetFileTypes(pofd, 2, @rgFileTypes(1))
            ' Set the title of the dialog
            hr = pofd->lpVtbl->SetTitle(pofd, L(426,"Load Session"))

        case IDM_PROJECTOPEN
            rgFileTypes(1).pszName = @L(216,"Project files")
            rgFileTypes(1).pszSpec = @wstr("*" & APPEXTENSION)
            rgFileTypes(2).pszName = @L(79,"All files")
            rgFileTypes(2).pszSpec = @wstr("*.*")
            pofd->lpVtbl->SetFileTypes(pofd, 2, @rgFileTypes(1))
            ' Set the title of the dialog
            hr = pofd->lpVtbl->SetTitle(pofd, L(216,"Project files"))
        
        case IDM_INSERTFILE
            rgFileTypes(1).pszName = @L(106,"Source files")
            rgFileTypes(2).pszName = @L(77,"Code files")
            rgFileTypes(3).pszName = @L(78,"Header files")
            rgFileTypes(4).pszName = @L(209,"Resource files")
            rgFileTypes(5).pszName = @L(79,"All files")
            rgFileTypes(1).pszSpec = @wstr("*.bas;*.bi;*.inc;*.rc")
            rgFileTypes(2).pszSpec = @wstr("*.bas;*.inc")
            rgFileTypes(3).pszSpec = @wstr("*.bi")
            rgFileTypes(4).pszSpec = @wstr("*.rc")
            rgFileTypes(5).pszSpec = @wstr("*.*")
            pofd->lpVtbl->SetFileTypes(pofd, 5, @rgFileTypes(1))
            ' Set the title of the dialog
            hr = pofd->lpVtbl->SetTitle(pofd, L(80,"Insert File"))

        case IDC_FRMOPTIONSLOCAL_CMDLOCALIZATION  '1012
            rgFileTypes(1).pszName = @L(102,"Localization files")
            rgFileTypes(1).pszSpec = @wstr("*.lang")
            rgFileTypes(2).pszName = @L(79,"All files")
            rgFileTypes(2).pszSpec = @wstr("*.*")
            pofd->lpVtbl->SetFileTypes(pofd, 2, @rgFileTypes(1))
            ' Set the title of the dialog
            hr = pofd->lpVtbl->SetTitle(pofd, L(103,"Open Localization File"))
    
            dim as CWSTR wszDefaultFolder = AfxGetExePathName & wstr("settings\languages\") 
            dim pFolder as IShellItem ptr
            SHCreateItemFromParsingName (wszDefaultFolder, null, @IID_IShellItem, @pFolder)
            if pFolder then
                hr = pofd->lpVtbl->SetFolder(pofd, pFolder)
                if SUCCEEDED(hr) then
                    pFolder->lpVtbl->Release(pFolder)
                end if      
            end if

        case IDC_FRMUSERTOOLS_CMDBROWSEEXE
            rgFileTypes(1).pszName = @L(79,"All files")
            rgFileTypes(1).pszSpec = @wstr("*.*")
            pofd->lpVtbl->SetFileTypes(pofd, 1, @rgFileTypes(1))
            ' Set the title of the dialog
            hr = pofd->lpVtbl->SetTitle(pofd, L(4,"Open File"))
    
            dim as CWSTR wszDefaultFolder = AfxGetExePathName & wstr("settings\tools\") 
            dim pFolder as IShellItem ptr
            SHCreateItemFromParsingName (wszDefaultFolder, null, @IID_IShellItem, @pFolder)
            if pFolder then
                hr = pofd->lpVtbl->SetFolder(pofd, pFolder)
                if SUCCEEDED(hr) then
                    pFolder->lpVtbl->Release(pFolder)
                end if      
            end if

        case IDC_FRMOPTIONSCOMPILER_CMDFBHELPFILE 
            rgFileTypes(1).pszName = @L(104,"Help file")
            rgFileTypes(1).pszSpec = @wstr("*.chm")
            rgFileTypes(2).pszName = @L(79,"All files")
            rgFileTypes(2).pszSpec = @wstr("*.*")
            pofd->lpVtbl->SetFileTypes(pofd, 2, @rgFileTypes(1))
            ' Set the title of the dialog
            hr = pofd->lpVtbl->SetTitle(pofd, L(105,"Find Help File"))

            dim as CWSTR wszDefaultFolder = AfxGetExePathName & wstr("settings\help\") 
            dim pFolder as IShellItem ptr
            SHCreateItemFromParsingName (wszDefaultFolder, null, @IID_IShellItem, @pFolder)
            if pFolder then
                hr = pofd->lpVtbl->SetFolder(pofd, pFolder)
                if SUCCEEDED(hr) then
                    pFolder->lpVtbl->Release(pFolder)
                end if      
            end if

    end select
    
    ' Display the dialog
    hr = pofd->lpVtbl->Show(pofd, hwndOwner)
    hr = pofd->lpVtbl->SetOptions(pofd, FOS_NOCHANGEDIR)

    ' Get the result
    dim pItem as IShellItem ptr
    dim pwszName as wstring ptr
    if SUCCEEDED(hr) then
        hr = pofd->lpVtbl->GetResult(pofd, @pItem)
        if SUCCEEDED(hr) then
            hr = pItem->lpVtbl->GetDisplayName(pItem, SIGDN_FILESYSPATH, @pwszName)
            function = pwszName
        end if
    end if

    ' Cleanup
    if pItem then pItem->lpVtbl->Release(pItem)
    if pofd then pofd->lpVtbl->Release(pofd)

end function


' ========================================================================================
' Displays the FileOpenDialog (multiple selection)
' returns a pointer to the IShellItemArray collection.
' ========================================================================================
function AfxIFileOpenDialogMultiple( _
            byval hwndOwner as hwnd, _
            byval idButton as long _
            ) as IShellItemArray ptr

    ' Create an instance of the FileOpenDialog interface
    dim hr as long
    dim pofd as IFileOpenDialog ptr
    hr = CoCreateInstance( @CLSID_FileOpenDialog, null, CLSCTX_INPROC_SERVER, _
                                @IID_IFileOpenDialog, @pofd)
    if pofd = null then return null

    ' Set the file types
    dim rgFileTypes(1 To 5) as COMDLG_FILTERSPEC

    select case idButton
        case IDM_FILEOPEN
            rgFileTypes(1).pszName = @L(106,"Source files")
            rgFileTypes(2).pszName = @L(77,"Code files")
            rgFileTypes(3).pszName = @L(78,"Header files")
            rgFileTypes(4).pszName = @L(209,"Resource files")
            rgFileTypes(5).pszName = @L(79,"All files")
            rgFileTypes(1).pszSpec = @wstr("*.bas;*.bi;*.inc;*.rc")
            rgFileTypes(2).pszSpec = @wstr("*.bas;*.inc")
            rgFileTypes(3).pszSpec = @wstr("*.bi")
            rgFileTypes(4).pszSpec = @wstr("*.rc")
            rgFileTypes(5).pszSpec = @wstr("*.*")
            pofd->lpVtbl->SetFileTypes(pofd, 5, @rgFileTypes(1))
    end select

    ' Set the title of the dialog
    hr = pofd->lpVtbl->SetTitle(pofd, L(248,"Open file"))

    ' Set the default folder to display in the open dialog
    dim wszDefaultFolder as wstring * MAX_PATH
    if gApp.wszLastOpenFolder = "" then 
        if AfxFileExists( gApp.ProjectFilename ) then 
            wszDefaultFolder = AfxStrPathName( "PATH", gApp.ProjectFilename )
        else
            wszDefaultFolder = AfxGetCurDir
        end if
    else
        wszDefaultFolder = gApp.wszLastOpenFolder
    end if
    
    dim pFolder as IShellItem ptr
    SHCreateItemFromParsingName (wszDefaultFolder, null, @IID_IShellItem, @pFolder)
    if pFolder then
        hr = pofd->lpVtbl->SetFolder(pofd, pFolder)
        if SUCCEEDED(hr) then
            pFolder->lpVtbl->Release(pFolder)
        end if      
    end if
    
    ' Allow multiselection
    hr = pofd->lpVtbl->SetOptions(pofd, FOS_ALLOWMULTIselect or FOS_NOCHANGEDIR or FOS_FILEMUSTEXIST)
    ' Display the dialog
    hr = pofd->lpVtbl->Show(pofd, hwndOwner)

    ' Get the result
    dim pItemArray as IShellItemArray ptr
    if SUCCEEDED(hr) then
        hr = pofd->lpVtbl->GetResults(pofd, @pItemArray)
        function = pItemArray
    end if

    if pofd then pofd->lpVtbl->Release(pofd)

end function


' ========================================================================================
' Displays the FileSaveDialog
' The returned pointer must be freed with CoTaskMemFree
' ========================================================================================
function AfxIFileSaveDialog( _
            byval hwndOwner as hwnd, _
            byval pwszFileName as wstring ptr, _    ' full path and filename
            byval pwszDefExt as wstring ptr, _
            byval id as long = 0, _
            byval sigdnName as SIGDN = SIGDN_FILESYSPATH _
            ) as wstring ptr

    ' // Create an instance of the IFileSaveDialog interface
    dim rgFileTypes(1 To 5) as COMDLG_FILTERSPEC 
    dim hr as long
    dim psfd as IFileSaveDialog ptr
    hr = CoCreateInstance(@CLSID_FileSaveDialog, null, CLSCTX_INPROC_SERVER, @IID_IFileSaveDialog, @psfd)
    if psfd = null then return null

    dim as CWSTR wszFilename, wszFilePath 
    
    ' Add extensions if it does not already exist as part of the filename
    wszFilename = AfxStrPathname( "NAMEX", *pwszFileName )
    if len(wszFilename) then 
        if AfxStrPathname( "EXTN", wszFilename ) = "" then
            if len(*pwszDefExt) then
            wszFilename = wszFilename & "." & *pwszDefExt
            end if   
        end if   
    end if
    
    if AfxFileExists( *pwszFileName ) then
        wszFilePath = AfxStrPathName( "PATH", *pwszFileName )
    else   
        ' Set the default folder to save the file
        if gApp.wszLastOpenFolder then 
            wszFilePath = gApp.wszLastOpenFolder
        else
            ' New file being saved try to default to the project folder
            if AfxFileExists( gApp.ProjectFilename ) then
                wszFilePath = AfxStrPathname( "PATH", gApp.ProjectFilename )
            end if
        end if
        gApp.wszLastOpenFolder = wszFilePath
    end if

    ' Set the file types
    select case id
        case IDM_SAVESESSION
            rgFileTypes(1).pszName = @wstr("Session files")
            rgFileTypes(1).pszSpec = @wstr("*.session")
            rgFileTypes(2).pszName = @L(79,"All files")
            rgFileTypes(2).pszSpec = @wstr("*.*")
            psfd->lpVtbl->SetFileTypes(psfd, 2, @rgFileTypes(1))
            ' // Set the title of the dialog
            hr = psfd->lpVtbl->SetTitle(psfd, L(425,"Save Session"))

        case IDM_FILERENAME
            rgFileTypes(1).pszName = @L(79,"All files")
            rgFileTypes(1).pszSpec = @wstr("*.*")
            psfd->lpVtbl->SetFileTypes(psfd, 1, @rgFileTypes(1))
            ' // Set the title of the dialog
            hr = psfd->lpVtbl->SetTitle(psfd, L(21,"Rename"))

        case IDC_FRMPROJECTOPTIONS_CMDSELECT, IDM_PROJECTSAVE, IDM_PROJECTSAVEAS
            rgFileTypes(1).pszName = @L(216,"Project files")
            rgFileTypes(1).pszSpec = @wstr("*" & APPEXTENSION)
            rgFileTypes(2).pszName = @L(79,"All files")
            rgFileTypes(2).pszSpec = @wstr("*.*")
            psfd->lpVtbl->SetFileTypes(psfd, 2, @rgFileTypes(1))
            ' // Set the title of the dialog
            hr = psfd->lpVtbl->SetTitle(psfd, L(185,"Save Project As..."))

        case IDC_FRMOPTIONSLOCAL_CMDNEW
            rgFileTypes(1).pszName = @L(102,"Localization files")
            rgFileTypes(1).pszSpec = @wstr("*.lang")
            rgFileTypes(2).pszName = @L(79,"All files")
            rgFileTypes(2).pszSpec = @wstr("*.*")
            psfd->lpVtbl->SetFileTypes(psfd, 2, @rgFileTypes(1))
            psfd->lpVtbl->SetTitle(psfd, L(8,"Save As..."))

            dim as CWSTR wszDefaultFolder = AfxGetExePathName & wstr("settings\languages\") 
            dim pFolder as IShellItem ptr
            SHCreateItemFromParsingName (wszDefaultFolder, null, @IID_IShellItem, @pFolder)
            if pFolder then
                hr = psfd->lpVtbl->SetFolder(psfd, pFolder)
                if SUCCEEDED(hr) then
                    pFolder->lpVtbl->Release(pFolder)
                end if      
            end if

        case else
            rgFileTypes(1).pszName = @L(106,"Source files")
            rgFileTypes(2).pszName = @L(77,"Code files")
            rgFileTypes(3).pszName = @L(78,"Header files")
            rgFileTypes(4).pszName = @L(209,"Resource files")
            rgFileTypes(5).pszName = @L(79,"All files")
            rgFileTypes(1).pszSpec = @wstr("*.bas;*.bi;*.inc;*.rc")
            rgFileTypes(2).pszSpec = @wstr("*.bas;*.inc")
            rgFileTypes(3).pszSpec = @wstr("*.bi")
            rgFileTypes(4).pszSpec = @wstr("*.rc")
            rgFileTypes(5).pszSpec = @wstr("*.*")
            psfd->lpVtbl->SetFileTypes(psfd, 5, @rgFileTypes(1))
            psfd->lpVtbl->SetTitle(psfd, L(8,"Save As..."))
            if pwszDefExt then 
                if *pwszDefExt = "inc" then
                    psfd->lpVtbl->SetFileTypeIndex(psfd, 2)
                end if
            end if
    end select
    
    ' // Set the file name
    hr = psfd->lpVtbl->SetFileName(psfd, wszFileName)
    ' // Set the extension
    hr = psfd->lpVtbl->SetDefaultExtension(psfd, pwszDefExt)

    ' // Set the default folder to display in the save dialog
    if id <> IDC_FRMOPTIONSLOCAL_CMDNEW then
        if len(wszFilePath ) then
            dim pFolder as IShellItem ptr
            SHCreateItemFromParsingName (wszFilePath, null, @IID_IShellItem, @pFolder)
            if pFolder then
                hr = psfd->lpVtbl->SetFolder(psfd, pFolder)
                if SUCCEEDED(hr) then
                pFolder->lpVtbl->Release(pFolder)
                end if      
            end if
        end if
    end if
    
    ' // Display the dialog
    hr = psfd->lpVtbl->Show(psfd, hwndOwner)

    ' // Get the result
    dim pItem as IShellItem ptr
    dim pwszName as wstring ptr
    if SUCCEEDED(hr) then
        hr = psfd->lpVtbl->GetResult(psfd, @pItem)
        if SUCCEEDED(hr) then
            hr = pItem->lpVtbl->GetDisplayName(pItem, sigdnName, @pwszName)
            function = pwszName
        end if
    end if
    ' // Cleanup
    if pItem then pItem->lpVtbl->Release(pItem)
    if psfd then psfd->lpVtbl->Release(psfd)

end function


' ========================================================================================
' Inserts an item at a specific location in the ListView.
' ========================================================================================
function LV_InsertItem( _
            byval hwndControl as HWND, _
            byval iRow        as long, _         
            byval iColumn     as long, _
            byval pwszText    as wstring ptr, _
            byval lParam      as LPARAM = 0 _
            ) as boolean

    dim lvi as LVITEMW
    lvi.iItem     = iRow
    lvi.iSubItem  = iColumn 
    lvi.pszText   = pwszText
    lvi.lParam    = lParam
    if iColumn = 0 then
        lvi.mask = LVIF_TEXT or LVIF_PARAM or LVIF_IMAGE 
        function = SendMessage( hwndControl, LVM_INSERTITEM, 0, cast(LPARAM, @lvi) )
    else 
        lvi.mask = LVIF_TEXT or LVIF_IMAGE
        function = SendMessage( hwndControl, LVM_SETITEM, 0, cast(LPARAM, @lvi) )
    end if
end function


' ========================================================================================
' Retrieves the text of a ListView item.
' ========================================================================================
function LV_GetItemText( _
            byval hwndControl as HWND, _
            byval iRow as long, _
            byval iColumn as long, _
            byval pwszText as wstring ptr, _
            byval nTextMax as long _
            ) as boolean

    if pwszText = 0 then return false
    if nTextMax = 0 then return false
    dim lvi as LVITEMW

    lvi.mask       = LVIF_TEXT
    lvi.iItem      = iRow
    lvi.iSubItem   = iColumn 
    lvi.pszText    = pwszText
    lvi.cchTextMax = nTextMax
        
    function = SendMessage( hwndControl, LVM_GETITEM, 0, cast(LPARAM, @lvi) )
end function


' ========================================================================================
' Set the text for the specified row and col item
' ========================================================================================
function LV_SetItemText( _
            byval hwndControl as HWND, _
            byval iRow as long, _
            byval iColumn as long, _
            byval pwszText as wstring ptr, _
            byval nTextMax as long _
            ) as long

    dim li as LV_ITEM
    li.mask       = LVIF_TEXT
    li.iItem      = iRow
    li.iSubItem   = iColumn 
    li.pszText    = pwszText
    li.cchTextMax = nTextMax
    function = SendMessage( hwndControl, LVM_SETITEM, 0, cast(LPARAM, @li) )
end function


' ========================================================================================
' Load a .lang localization file from disk and populate the localization array
' The IsEnglish parameter is used when we want to populate the gLangEnglish global
' array that is used in the editor startup code.
' ========================================================================================
function LoadLocalizationFile( _
            byref wszFileName as CWSTR, _
            byval IsEnglish as boolean = false _
            ) as boolean

    ' default that the file failed to load
    function = false
    if AfxFileExists( wszFileName ) = 0 then exit function

    dim as CBSTR wst, wKey, wData
    dim nKey  as long
    dim nData as long  
    dim i     as long
    
    dim pStream as CTextStream
    if pStream.OpenUnicode( wszFileName ) <> S_OK then exit function
    
    do until pStream.EOS
        wst = pStream.ReadLine
        
        if len(wst) = 0 then continue Do
        if left(wst, 1) = "'" then continue Do
        
        i = instr(wst, ":")
        if i = 0 then continue Do
        
        wKey = "": wData = "": nData = 0

        wKey  = left(wst, i-1)
        wData = mid(**wst, i+1)    ' MID causes problems with Chinese data so ** is used.
        
        nKey  = val(wKey)
        nData = val(wData)

        if ucase(wKey) = "MAXIMUM" then
            ' resize the global dynamic array
            if IsEnglish then
                redim gLangEnglish(nData) as wstring * MAX_PATH
            else   
                redim LL(nData) as wstring * MAX_PATH
            end if
        else
            ' this should be a key/value pair line in the format:
            ' 00001:value
            ' Ensure that we add the value to the array within the valid
            ' boundaries of the array.
            if IsEnglish then
                if (nKey >= lbound(gLangEnglish)) andalso (nKey <= ubound(gLangEnglish)) then
                    ' Use ** to ensure that cyrillic langauge gets converted correctly. FB intrinsic
                    ' functions (RTRIM) automatically convert those incorrectly when using CBSTR or CWSTR.
                    gLangEnglish(nKey) = rtrim(**AfxStrParse(wData, 1, ";"), any chr(9,32))
                end if
            else
                if (nKey >= lbound(LL)) andalso (nKey <= ubound(LL)) then
                    ' Remove any comments from end of the line. Comments begin with
                    ' a semicolon character.
                    ' Use ** to ensure that cyrillic langauge gets converted correctly. FB intrinsic
                    ' functions (RTRIM) automatically convert those incorrectly when using CBSTR or CWSTR.
                    LL(nKey) = rtrim(**AfxStrParse(wData, 1, ";"), any chr(9,32))
                    ' if the local phrase is empty then fill it using the English version.
                    if len(LL(nKey)) = 0 then 
                        if (nKey >= lbound(gLangEnglish)) andalso (nKey <= ubound(gLangEnglish)) then
                            LL(nKey) = gLangEnglish(nKey)
                        end if
                    end if   
                end if
            end if
        end if   
            
    loop
    pStream.Close
    
    function = true
end function


' ========================================================================================
' Get the full process image name
' ========================================================================================
function GetProcessImageName( _
            byval pe32w as PROCESSENTRY32W ptr, _
            byval pwszExeName as wstring ptr _
            ) as long

    dim dwSize as long
    dim hProcess as HANDLE 
    hProcess = OpenProcess(PROCESS_QUERY_INFORMATION or PROCESS_VM_READ, 1, pe32w->th32ProcessID)
    if hProcess then
        dwSize = MAX_PATH
        
'      Without using dynamic loading...      
'      QueryFullProcessImageNameW( hProcess, 0, pwszExeName, @dwSize ) 
'      CloseHandle hProcess

        ' QueryFullProcessImageNameW is only available in Vista or higher. Try to dynamically load the 
        ' function because statically linking to it will cause a runtime error if the editor is run using WinXP.
        dim as any ptr hLib = dylibload("Kernel32")
        if hLib then
            dim MyQueryFullProcessImageName as function( byval hProcess as HANDLE, byval dwFlags as DWORD, byval lpExeName as LPWSTR, byval lpdwSize as PDWORD) as WINBOOL
            MyQueryFullProcessImageName = dylibsymbol( hLib, "QueryFullProcessImageNameW" )
            if MyQueryFullProcessImageName then
                MyQueryFullProcessImageName( hProcess, 0, pwszExeName, @dwSize ) 
                CloseHandle hProcess
            end if
            DyLibFree(hLib)
        end if

    end if
    function = 0
end function


' ========================================================================================
' Checks if the program that we are going to compile is already running
' ========================================================================================
function IsProcessRunning( byval pwszExeFileName as wstring ptr ) as boolean

    dim hSnapShot as HANDLE
    dim pe32w as PROCESSENTRY32W

    dim wszExeFileName as wstring * MAX_PATH = ucase(*pwszExeFileName)
    dim wszExeProcessName as wstring * MAX_PATH

    pe32w.dwSize = sizeof(pe32w)
    hSnapShot = CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, 0)

    if hSnapShot <> INVALID_HANDLE_VALUE then
        if Process32First(hSnapShot, @pe32w) then
            GetProcessImageName( @pe32w, @wszExeProcessName )
            if ucase(wszExeProcessName) = wszExeFileName then
                function = true
            else
                do while Process32next(hSnapShot, @pe32w) > 0
                    GetProcessImageName( @pe32w, @wszExeProcessName )
                    if ucase(wszExeProcessName) = wszExeFileName then
                        function = true
                        exit Do
                    end if
                loop
            end if
        end if
        CloseHandle hSnapShot
    end if

    return false
end function


' ========================================================================================
' Determine the EXE name of the currently active document or project.
' ========================================================================================
function GetRunExecutableFilename() as CWSTR
    ' Used by the top menu to determine if the Run Executable option is available
    dim wszFilename as CWSTR
    dim wszOptions as CWSTR
    dim pDocMain as clsDocument ptr 

    dim as long idxBuild = frmBuildConfig_getActiveBuildIndex()
    dim as boolean bInstring = false
    
    pDocMain = iif( gApp.IsProjectActive, gApp.GetMainDocumentPtr, gTTabCtl.GetActiveDocumentPtr)
    if pDocMain = 0 then return ""
    
    if idxBuild > -1 then 
        wszOptions = gConfig.Builds(idxBuild).wszOptions 

        if gApp.IsProjectActive then
            if gConfig.Builds(idxBuild).Is32bit then
                wszOptions = wszOptions + " " + gApp.ProjectOther32
            end if   
            if gConfig.Builds(idxBuild).Is64bit then
                wszOptions = wszOptions + " " + gApp.ProjectOther64
            end if   
        else
            wszOptions = wszOptions + " " + gConfig.CompilerSwitches
        end if
        wszOptions = " " + ucase(wszOptions) + " "
        
        if instr(wszOptions, wstr(" -DLL "))   then return ""
        if instr(wszOptions, wstr(" -DYLIB ")) then return ""
        if instr(wszOptions, wstr(" -LIB "))   then return ""
        
    end if
    
    ' Need to check the compiler options to see if the -x switch is used. That switch specifically
    ' names the output file.
    dim y as long = instr(wszOptions, wstr(" -X "))
    if y then
        y = y + 4  ' skip over the switch itself
        for i as long = y to len(wszOptions)
            ' iterate to the beginning of the next switch or end of the string
            ' skip over spaces that are part of a filename string
            if wszOptions[i-1] = 34 then bInstring = not bInstring  ' double quotes
            if bInstring then continue for
            if wszOptions[i-1] = 45 then  ' dash   
                wszFilename = mid(wszOptions, y, i-y-1)
                exit for
            end if   
        next
        ' There was no other switch so we made it to the end of the string
        if len(wszFilename) = 0 then wszFilename = mid(wszOptions, y)
    end if
    
    ' Has a filename been determined yet? if it has then it possibly does not have
    ' a path assigned to it so we should add one.
    if len(wszFilename) then
        if len(AfxStrPathname("PATH", wszFilename)) = 0 then
            wszFilename = AfxStrPathname("PATH", pDocMain->DiskFilename) + wszFilename
        end if
    else
        ' Default 
        wszFilename = AfxStrPathname("PATH", pDocMain->DiskFilename) + _
                    AfxStrPathname("NAME", pDocMain->DiskFilename) + _
                    wstr(".exe")
    end if

    return wszFilename

end function


' ========================================================================================
' Calcluate the client area at bottom of Listbox not covered by a row (needed to manually
' paint the unused area in WM_ERASEBKGRD messages to avoid flicker.
' ========================================================================================
function GetListBoxEmptyClientArea( _
            byval hListBox as HWND, _
            byval nLineHeight as long _
            ) as RECT
    
    dim as RECT rc: GetClientRect( hListBox, @rc )
    ' if the number of lines in the listbox is less than the number per page then 
    ' calculate from last item to bottom of listbox, otherwise calculate based on
    ' the mod of the lineheight to listbox height so we can color the partial line
    ' that won't be displayed at the bottom of the list.
    dim as RECT rcItem
    SendMessage( hListBox, LB_GETITEMRECT, 0, cast(LPARAM, @rcItem) )
    dim as long itemHeight = rcItem.bottom - rcItem.top
    dim as long NumItems = ListBox_GetCount(hListBox)
    dim as long ItemsPerPage = ( rc.bottom \ itemHeight )
    dim as long nTopIndex = SendMessage( hListBox, LB_GETTOPINDEX, 0, 0 ) 
    dim as long visible_rows = 0

    if NumItems > 0 then
        ItemsPerPage = (rc.bottom - rc.top) / itemHeight
        dim as long bottom_index = (nTopIndex + ItemsPerPage)
        if bottom_index >= NumItems then bottom_index = NumItems - 1
        visible_rows = (bottom_index - nTopIndex) + 1
    end if

    rc.top = visible_rows * itemHeight 
    if rc.top > rc.bottom then rc.top = rc.bottom
    
    return rc
end function
